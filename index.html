<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Swipe Snake Game (Multiplayer High Scores)</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --game-bg: #1f2937; /* Dark blue-gray */
            --snake-color: #10b981; /* Emerald Green */
            --food-color: #f87171; /* Red */
            --score-color: #fcd34d; /* Amber */
            --active-speed: #34d399;
            --inactive-speed: #4b5563;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0f172a; /* Deeper background */
            font-family: 'VT323', monospace;
            color: #e5e7eb;
            user-select: none; /* Prevent selection on touchscreens */
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            border-radius: 16px;
            background-color: var(--game-bg);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            text-align: center;
            color: var(--score-color);
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            text-shadow: 0 0 5px rgba(252, 211, 77, 0.5);
        }

        #gameCanvas {
            border: 4px solid var(--snake-color);
            border-radius: 8px;
            background-color: #2c3648;
            touch-action: none; /* Critical for preventing browser swipe actions */
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            padding: 5px 0;
        }

        .score-box {
            color: var(--score-color);
        }

        .speed-box {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 1.2rem;
            color: #9ca3af;
        }
        .speed-box span {
            color: var(--score-color);
            font-size: 1.5rem;
        }

        .controls-info {
            text-align: center;
            font-size: 1rem;
            color: #9ca3af;
        }

        /* Modal styling for game over/start */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background: #374151;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 80%;
        }

        .modal-content h2 {
            color: var(--food-color);
            margin-top: 0;
        }
        .modal-content p {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .action-button {
            padding: 10px 20px;
            font-size: 1.5rem;
            font-family: 'VT323', monospace;
            color: var(--game-bg);
            background-color: var(--snake-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 0 #065f46; /* Darker green for depth */
            position: relative;
            top: 0;
            margin-top: 20px;
        }

        .action-button:active {
            box-shadow: 0 0 0 0 #065f46;
            top: 4px;
        }
        
        /* Speed Selection Styles */
        .speed-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .speed-label {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            background-color: var(--inactive-speed);
            color: #e5e7eb;
            font-size: 1rem;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Hide the actual radio input */
        .speed-selector input[type="radio"] {
            display: none;
        }
        
        /* Style the label when the corresponding radio is checked */
        .speed-selector input[type="radio"]:checked + .speed-label {
            background-color: var(--active-speed);
            color: var(--game-bg);
            font-weight: bold;
        }
        
        /* High Score Table Styles */
        .high-scores-table {
            width: 100%;
            margin-top: 15px;
            border-collapse: collapse;
            font-size: 1.2rem;
            text-align: left;
        }
        .high-scores-table th, .high-scores-table td {
            padding: 8px 12px;
            border-bottom: 1px dashed #4b5563;
        }
        .high-scores-table th {
            color: var(--snake-color);
            text-transform: uppercase;
            font-size: 1.3rem;
            border-bottom: 2px solid var(--snake-color);
        }
        .high-scores-table tr:last-child td {
            border-bottom: none;
        }
        .high-scores-table .score-rank {
            width: 10%;
            text-align: right;
            color: var(--score-color);
        }
        .high-scores-table .score-value {
            color: #fca34d;
            font-weight: bold;
            text-align: right;
        }
        #playerNameInput {
            color: #1f2937; /* Dark text for input */
            text-transform: uppercase;
        }
        .loading-text {
            color: #a7f3d0;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>SNAKE SWIPE</h1>
        <div class="info-panel">
            <div class="score-box">Score: <span id="scoreValue">0</span></div>
            <div class="speed-box">Speed: <span id="speedValue">Medium</span></div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="controls-info">
            Use **WASD** or **Arrow Keys** on keyboard.
        </div>
        <div class="controls-info">
            **Swipe** on the canvas to control the snake on touch devices.
        </div>
        
        <div class="controls-info text-xs text-gray-500 mt-2">
            User ID: <span id="userIdDisplay">Authenticating...</span>
        </div>

        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">Welcome to Snake Swipe!</h2>
                
                <p>Select Speed:</p>
                <div class="speed-selector" id="speedSelector">
                    <!-- Speed radio buttons will be inserted here -->
                </div>
                
                <!-- High Scores Display -->
                <div id="highScoresDisplay" class="mb-4">
                    <p class="loading-text">Loading High Scores...</p>
                </div>
                
                <!-- New High Score Input Section (Initially Hidden) -->
                <div id="newHighScoreForm" class="hidden my-4 p-4 border border-green-500 rounded-lg bg-green-900/50">
                    <p class="text-xl text-green-300">You set a New Global High Score!</p>
                    <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="15" class="p-2 w-full text-base rounded bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-green-500 my-2 font-mono" />
                    <button id="saveScoreButton" class="action-button bg-green-500 hover:bg-green-600 shadow-green-700">Save Score</button>
                </div>

                <p id="modalText">Eat the red food to grow. Avoid the walls and your own tail!</p>
                <button id="startButton" class="action-button">Start Game</button>
            </div>
        </div>

    </div>

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        
        // setLogLevel('Debug'); // Uncomment for debugging Firestore logs

        // --- Firebase Setup ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;
        let userId = null;
        let isAuthReady = false;
        
        // Game Constants
        const TILE_SIZE = 20;
        const CANVAS_SIZE = 400; 
        const MAX_COLS = CANVAS_SIZE / TILE_SIZE;
        const MAX_ROWS = CANVAS_SIZE / TILE_SIZE;
        const COLLECTION_NAME = 'snake_high_scores';
        const MAX_HIGH_SCORES = 5;
        
        // Speed Map (ms delay between updates: lower is faster)
        const SPEED_MAP = {
            'Slow': 200, 
            'Medium': 150, 
            'Fast': 100, 
            'Expert': 50
        };
        const INITIAL_SPEED_KEY = 'Medium';
        
        // Game State
        let canvas, ctx;
        let snake;
        let food;
        let dx, dy; // Direction
        let score;
        let gameLoopId;
        let lastUpdateTime;
        let gameSpeed;
        let isPaused = true;
        let nextDx = 1;
        let nextDy = 0;
        let selectedSpeedKey = INITIAL_SPEED_KEY;
        let globalHighScores = [];

        // Touch State for Swiping
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30;

        // Elements
        const scoreValueEl = document.getElementById('scoreValue');
        const speedValueEl = document.getElementById('speedValue');
        const modalEl = document.getElementById('gameModal');
        const modalTitleEl = document.getElementById('modalTitle');
        const modalTextEl = document.getElementById('modalText');
        const startButton = document.getElementById('startButton');
        const speedSelectorEl = document.getElementById('speedSelector');
        const highScoresDisplayEl = document.getElementById('highScoresDisplay');
        const newHighScoreFormEl = document.getElementById('newHighScoreForm');
        const playerNameInputEl = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const userIdDisplayEl = document.getElementById('userIdDisplay');

        // --- Firebase & High Score Functions ---
        
        /**
         * Initializes Firebase and sets up the Auth state listener.
         */
        async function setupFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config not found. High scores will not be saved.");
                    isAuthReady = true;
                    userId = "NO_AUTH";
                    return;
                }
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userIdDisplayEl.textContent = userId;
                        isAuthReady = true;
                        // Start listening to high scores once authenticated
                        listenForHighScores(); 
                    } else {
                        // Sign in if not authenticated
                        attemptSignIn();
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        }
        
        /**
         * Attempts to sign in using the custom token or anonymously.
         */
        async function attemptSignIn() {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase sign-in failed:", error);
                userId = "AUTH_ERROR";
                userIdDisplayEl.textContent = "AUTH_ERROR";
                isAuthReady = true;
                // Still try to display an empty score list if authentication fails
                displayHighScores(); 
            }
        }

        /**
         * Listens to real-time updates for the top 5 scores from Firestore.
         */
        function listenForHighScores() {
            if (!db || !isAuthReady) return;

            // Path for public/shared data: /artifacts/{appId}/public/data/snake_high_scores
            const scoresRef = collection(db, `artifacts/${appId}/public/data/${COLLECTION_NAME}`);
            
            // To emulate 'orderBy' and 'limit' without using them (due to index issues):
            // We fetch all available docs and sort/limit client-side.
            // A dedicated field for sorting is still needed. Let's assume 'score' is that field.
            
            const q = query(scoresRef);

            onSnapshot(q, (snapshot) => {
                let scores = [];
                snapshot.forEach(doc => {
                    scores.push(doc.data());
                });

                // 1. Sort by score descending
                scores.sort((a, b) => b.score - a.score);
                
                // 2. Limit to top 5
                globalHighScores = scores.slice(0, MAX_HIGH_SCORES);
                
                // 3. Update the display only if the modal is visible
                if (modalEl.style.display !== 'none') {
                    displayHighScores();
                }
            }, (error) => {
                console.error("Error listening to high scores:", error);
                highScoresDisplayEl.innerHTML = '<p class="text-red-400">Failed to load scores.</p>';
            });
        }
        
        /**
         * Renders the high scores table in the modal using globalHighScores array.
         */
        function displayHighScores() {
            const scores = globalHighScores;
            
            if (scores.length === 0) {
                highScoresDisplayEl.innerHTML = '<p class="text-gray-400">No high scores yet! Be the first.</p>';
                return;
            }

            let tableHTML = `
                <table class="high-scores-table">
                    <thead>
                        <tr>
                            <th class="score-rank">#</th>
                            <th>Player</th>
                            <th>Speed</th>
                            <th class="score-value">Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            scores.forEach((record, index) => {
                // Ensure name and speed are capitalized for style
                const name = (record.name || 'Anonymous').toUpperCase();
                const speed = record.speed || 'N/A';

                tableHTML += `
                    <tr>
                        <td class="score-rank">${index + 1}.</td>
                        <td>${name}</td>
                        <td>${speed}</td>
                        <td class="score-value">${record.score}</td>
                    </tr>
                `;
            });
            
            tableHTML += '</tbody></table>';
            highScoresDisplayEl.innerHTML = tableHTML;
        }

        /**
         * Checks if the current score qualifies for the top 5 and updates the list.
         * Shows the name input form if the score is a high score.
         */
        function checkAndHandleHighScore() {
            const isHighScore = globalHighScores.length < MAX_HIGH_SCORES || score > globalHighScores[globalHighScores.length - 1].score;

            if (isHighScore) {
                // Show form to save name
                newHighScoreFormEl.classList.remove('hidden');
                playerNameInputEl.value = ''; // Clear previous input
                playerNameInputEl.focus();

                // Detach old listener, attach new one for saving
                saveScoreButton.onclick = submitHighScore;

                modalTextEl.textContent = 'Enter your name to save your score!';
                startButton.textContent = "Continue Without Saving";
                
            } else {
                // Not a high score
                newHighScoreFormEl.classList.add('hidden');
                modalTextEl.innerHTML = `Your Final Score: <strong style="color:var(--score-color);">${score}</strong>. Keep trying!`;
                startButton.textContent = "Play Again";
            }
            
            // Ensure the latest scores are displayed
            displayHighScores();
        }
        
        /**
         * Saves the player's name and score to the global high score collection.
         */
        async function submitHighScore() {
            if (!isAuthReady || !db) {
                console.warn("Database not ready or authentication failed. Score not saved.");
                alert("Cannot save score: Database connection failed."); // Using custom modal in real app
                return;
            }
            
            let name = playerNameInputEl.value.trim();
            if (name === '') {
                name = 'ANON';
            }
            
            const newRecord = {
                name: name,
                score: score,
                speed: selectedSpeedKey,
                userId: userId,
                timestamp: serverTimestamp() // Adds server-side timestamp
            };
            
            try {
                const scoresRef = collection(db, `artifacts/${appId}/public/data/${COLLECTION_NAME}`);
                await addDoc(scoresRef, newRecord);
                
                // Reset modal state after saving
                newHighScoreFormEl.classList.add('hidden');
                modalTextEl.innerHTML = `Score saved! Your Final Score: <strong style="color:var(--score-color);">${score}</strong>.`;
                startButton.textContent = "Play Again";
                // The onSnapshot listener will automatically update the displayed scores
            } catch (e) {
                console.error("Error saving high score:", e);
                modalTextEl.innerHTML = `Error saving score. Try again: <strong style="color:var(--score-color);">${score}</strong>.`;
            }
        }


        // --- UI and Game Logic (Unchanged from previous version, adapted for Firebase) ---

        /**
         * Renders the speed selection radio buttons in the modal.
         */
        function renderSpeedSelector() {
            speedSelectorEl.innerHTML = ''; // Clear previous buttons
            
            Object.keys(SPEED_MAP).forEach(key => {
                const isChecked = key === INITIAL_SPEED_KEY;
                
                const radioInput = document.createElement('input');
                radioInput.type = 'radio';
                radioInput.id = `speed-${key}`;
                radioInput.name = 'game-speed';
                radioInput.value = key;
                radioInput.checked = isChecked;
                radioInput.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedSpeedKey = key;
                    }
                });
                
                const label = document.createElement('label');
                label.htmlFor = `speed-${key}`;
                label.classList.add('speed-label');
                label.textContent = key;
                
                speedSelectorEl.appendChild(radioInput);
                speedSelectorEl.appendChild(label);
            });
            // Ensure the initial state is set
            selectedSpeedKey = INITIAL_SPEED_KEY;
        }
        
        /**
         * Initializes the game state and event listeners.
         */
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            
            setupFirebase(); // Start Firebase and Auth setup

            renderSpeedSelector();
            resetGame();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyPress);
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            startButton.addEventListener('click', startGame);

            // Initial Draw to show the board
            draw();
        }

        /**
         * Resets the snake, food, score, and direction.
         */
        function resetGame() {
            snake = [
                { x: 6, y: 10 },
                { x: 5, y: 10 },
                { x: 4, y: 10 }
            ];

            dx = 1;
            dy = 0;
            nextDx = 1;
            nextDy = 0;
            score = 0;
            isPaused = true;

            scoreValueEl.textContent = score;
            speedValueEl.textContent = selectedSpeedKey;
            
            spawnFood();
            
            if (gameLoopId) {
                clearInterval(gameLoopId);
            }
        }

        /**
         * Main game loop that updates the game state.
         */
        function mainLoop(timestamp) {
            if (isPaused) return;

            if (timestamp - lastUpdateTime < gameSpeed) {
                requestAnimationFrame(mainLoop);
                return;
            }
            lastUpdateTime = timestamp;
            
            dx = nextDx;
            dy = nextDy;

            update();
            draw();
            
            requestAnimationFrame(mainLoop);
        }
        
        /**
         * Starts the game loop.
         */
        function startGame() {
            gameSpeed = SPEED_MAP[selectedSpeedKey] || SPEED_MAP[INITIAL_SPEED_KEY];
            speedValueEl.textContent = selectedSpeedKey;
            
            modalEl.style.display = 'none';
            resetGame(); 
            isPaused = false;
            lastUpdateTime = performance.now();
            requestAnimationFrame(mainLoop);
        }

        /**
         * Displays the game over modal.
         */
        function gameOver() {
            isPaused = true;
            modalTitleEl.textContent = "Game Over!";
            
            // Check for high score and update modal content
            if (isAuthReady) {
                checkAndHandleHighScore();
            } else {
                 modalTextEl.innerHTML = `Your Final Score: <strong style="color:var(--score-color);">${score}</strong>.<br>Scores not saved: Authentication not ready.`;
                 startButton.textContent = "Play Again";
                 displayHighScores();
            }
            
            modalEl.style.display = 'flex';
        }

        /**
         * Generates food coordinates randomly, ensuring it doesn't overlap with the snake.
         */
        function spawnFood() {
            let newFood;
            let occupied;
            do {
                newFood = {
                    x: Math.floor(Math.random() * MAX_COLS),
                    y: Math.floor(Math.random() * MAX_ROWS)
                };

                occupied = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
                
            } while (occupied);

            food = newFood;
        }

        /**
         * Updates the position of the snake and checks for collisions (wall and self only).
         */
        function update() {
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            const wallCollision = head.x < 0 || head.x >= MAX_COLS || head.y < 0 || head.y >= MAX_ROWS;
            
            const selfCollision = snake.some((segment, index) => 
                index !== 0 && segment.x === head.x && segment.y === head.y
            );

            if (wallCollision || selfCollision) {
                gameOver();
                return;
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreValueEl.textContent = score;
                
                if (score % 50 === 0 && gameSpeed > SPEED_MAP['Expert']) {
                    gameSpeed -= 10; 
                }

                spawnFood();
            } else {
                snake.pop();
            }
        }

        /**
         * Draws the game elements on the canvas.
         */
        function draw() {
            ctx.fillStyle = '#2c3648';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#059669' : 'var(--snake-color)'; 
                ctx.strokeStyle = '#2c3648';
                
                ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.strokeRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            ctx.fillStyle = 'var(--food-color)';
            ctx.beginPath();
            const foodCenterX = food.x * TILE_SIZE + TILE_SIZE / 2;
            const foodCenterY = food.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.arc(foodCenterX, foodCenterY, TILE_SIZE / 2 * 0.7, 0, 2 * Math.PI);
            ctx.fill();
        }

        // --- Input Handling (Keyboard and Touch) ---

        function handleKeyPress(event) {
            if (isPaused) {
                if (event.key === ' ' || event.key === 'Enter') {
                    if (newHighScoreFormEl.classList.contains('hidden')) {
                        startGame();
                    } else if (event.key === 'Enter') {
                        submitHighScore();
                    }
                }
                return;
            }

            const key = event.key;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if ((key === 'ArrowLeft' || key === 'a') && !goingRight) {
                nextDx = -1; nextDy = 0;
            } else if ((key === 'ArrowUp' || key === 'w') && !goingDown) {
                nextDx = 0; nextDy = -1;
            } else if ((key === 'ArrowRight' || key === 'd') && !goingLeft) {
                nextDx = 1; nextDy = 0;
            } else if ((key === 'ArrowDown' || key === 's') && !goingUp) {
                nextDx = 0; nextDy = 1;
            }
        }

        function handleTouchStart(event) {
            if (isPaused) return;
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchMove(event) {
            if (isPaused || !touchStartX || !touchStartY) return;

            const touch = event.touches[0];
            const diffX = touch.clientX - touchStartX;
            const diffY = touch.clientY - touchStartY;

            if (Math.abs(diffX) > SWIPE_THRESHOLD || Math.abs(diffY) > SWIPE_THRESHOLD) {
                const goingUp = dy === -1;
                const goingDown = dy === 1;
                const goingRight = dx === 1;
                const goingLeft = dx === -1;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0 && !goingLeft) {
                        nextDx = 1; nextDy = 0;
                    } else if (diffX < 0 && !goingRight) {
                        nextDx = -1; nextDy = 0;
                    }
                } else {
                    if (diffY > 0 && !goingUp) {
                        nextDx = 0; nextDy = 1;
                    } else if (diffY < 0 && !goingDown) {
                        nextDx = 0; nextDy = -1;
                    }
                }
                
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            }
            
            event.preventDefault();
        }
        
        function handleTouchEnd(event) {
            touchStartX = 0;
            touchStartY = 0;
        }

        // Start the application setup
        window.onload = init;
    </script>
</body>
</html>

