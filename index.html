<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Swipe Snake Game (Universal Leaderboard)</title>
    
    <!-- PWA MANDATORY LINKS -->
    <meta name="theme-color" content="#10b981">
    <link rel="manifest" href="manifest.json"> 
    <link rel="apple-touch-icon" href="apple-touch-icon.png"> 

    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --game-bg: #1f2937; /* Dark blue-gray */
            --snake-color: #10b981; /* Emerald Green */
            --food-color: #f87171; /* Red */
            --score-color: #fcd34d; /* Amber */
            --active-speed: #34d399;
            --inactive-speed: #4b5563;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0f172a; /* Deeper background */
            font-family: 'VT323', monospace;
            color: #e5e7eb;
            user-select: none; /* Prevent selection on touchscreens */
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            border-radius: 16px;
            background-color: var(--game-bg);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            text-align: center;
            color: var(--score-color);
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            text-shadow: 0 0 5px rgba(252, 211, 77, 0.5);
        }

        #gameCanvas {
            border: 4px solid var(--snake-color);
            border-radius: 8px;
            background-color: #2c3648;
            touch-action: none; /* Critical for preventing browser swipe actions */
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            padding: 5px 0;
        }

        .score-box {
            color: var(--score-color);
        }

        .speed-box {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 1.2rem;
            color: #9ca3af;
        }
        .speed-box span {
            color: var(--score-color);
            font-size: 1.5rem;
        }

        .controls-info {
            text-align: center;
            font-size: 1rem;
            color: #9ca3af;
        }

        /* Modal styling for game over/start */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background: #374151;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 80%;
        }

        .modal-content h2 {
            color: var(--food-color);
            margin-top: 0;
        }
        .modal-content p {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .action-button {
            padding: 10px 20px;
            font-size: 1.5rem;
            font-family: 'VT323', monospace;
            color: var(--game-bg);
            background-color: var(--snake-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 0 #065f46; /* Darker green for depth */
            position: relative;
            top: 0;
            margin-top: 20px;
        }

        .action-button:active {
            box-shadow: 0 0 0 0 #065f46;
            top: 4px;
        }
        
        /* Speed Selection Styles */
        .speed-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .speed-label {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            background-color: var(--inactive-speed);
            color: #e5e7eb;
            font-size: 1rem;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Hide the actual radio input */
        .speed-selector input[type="radio"] {
            display: none;
        }
        
        /* Style the label when the corresponding radio is checked */
        .speed-selector input[type="radio"]:checked + .speed-label {
            background-color: var(--active-speed);
            color: var(--game-bg);
            font-weight: bold;
        }
        
        /* High Score Table Styles */
        .high-scores-table {
            width: 100%;
            margin-top: 15px;
            border-collapse: collapse;
            font-size: 1.2rem;
            text-align: left;
        }
        .high-scores-table th, .high-scores-table td {
            padding: 8px 12px;
            border-bottom: 1px dashed #4b5563;
        }
        .high-scores-table th {
            color: var(--snake-color);
            text-transform: uppercase;
            font-size: 1.3rem;
            border-bottom: 2px solid var(--snake-color);
        }
        .high-scores-table tr:last-child td {
            border-bottom: none;
        }
        .high-scores-table .score-rank {
            width: 10%;
            text-align: right;
            color: var(--score-color);
        }
        .high-scores-table .score-value {
            color: #fca34d;
            font-weight: bold;
            text-align: right;
        }
        #playerNameInput {
            color: #1f2937; /* Dark text for input */
            text-transform: uppercase;
        }
        .loading-text {
            color: #a7f3d0;
            font-size: 1.5rem;
        }
        .disclaimer {
            font-size: 0.8rem;
            color: #a7f3d0;
            margin-top: 10px;
        }
        .hidden {
            display: none;
        }
    </style>
    <!-- Tone.js for in-browser sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>

    <div class="game-container">
        <h1>SNAKE SWIPE</h1>
        <div class="info-panel">
            <div class="score-box">Score: <span id="scoreValue">0</span></div>
            <div class="speed-box">Speed: <span id="speedValue">Medium</span></div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="controls-info">
            Use **WASD** or **Arrow Keys** on keyboard.
        </div>
        <div class="controls-info">
            **Swipe** on the canvas to control the snake on touch devices.
        </div>
        
        <!-- Auth Status Display -->
        <div class="controls-info text-xs text-gray-500 mt-2">
            Status: <span id="authStatusDisplay">Connecting...</span>
        </div>
        
        <!-- Audio Context Activation Button (Hidden after activation) -->
        <button id="audio-start-btn" class="action-button" style="margin-top:10px; display:none;">
            Click to Enable Sound
        </button>

        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">Welcome to Snake Swipe!</h2>
                
                <p>Select Speed:</p>
                <div class="speed-selector" id="speedSelector">
                    <!-- Speed radio buttons will be inserted here -->
                </div>
                
                <!-- High Scores Display -->
                <div id="highScoresDisplay" class="mb-4">
                    <p class="loading-text">Loading Universal High Scores...</p>
                </div>

                <div id="configWarning" class="disclaimer hidden">
                    Leaderboard is live! Ensure Firestore security rules allow public read/write access to 'global_snake_scores'.
                </div>
                
                <!-- New High Score Input Section (Initially Hidden) -->
                <div id="newHighScoreForm" class="hidden my-4 p-4 border border-green-500 rounded-lg bg-green-900/50">
                    <p class="text-xl text-green-300">New Universal High Score!</p>
                    <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="15" class="p-2 w-full text-base rounded bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-green-500 my-2 font-mono" />
                    <button id="saveScoreButton" class="action-button bg-green-500 hover:bg-green-600 shadow-green-700">Save Score</button>
                </div>

                <p id="modalText">Eat the food to grow. Avoid the walls and your own tail!</p>
                <button id="startButton" class="action-button">Start Game</button>
            </div>
        </div>

    </div>

    <script type="module">
        // --- Firebase Imports (Using version 9 CDN links) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, orderBy, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-firestore.js";
        
        // =========================================================================
        // !!! LIVE FIREBASE CONFIGURATION !!!
        // Using the keys provided by the user for public deployment.
        // =========================================================================
        const FIREBASE_CONFIG = {
          apiKey: "AIzaSyC-dV6UbbgZ4KNV8jwPGNSiZwMFF_LDQXA",
          authDomain: "database-72f5c.firebaseapp.com",
          projectId: "database-72f5c",
          storageBucket: "database-72f5c.firebasestorage.app",
          messagingSenderId: "39760475308",
          appId: "1:39760475308:web:897ebdfaea3e052c5a9b09",
        };
        const COLLECTION_NAME = 'global_snake_scores'; // The collection where scores are saved
        // =========================================================================

        // --- Firebase Globals ---
        let db, auth;
        let isDbReady = false;
        let globalHighScores = [];

        // Game Constants
        const TILE_SIZE = 20;
        const CANVAS_SIZE = 400; 
        const MAX_COLS = CANVAS_SIZE / TILE_SIZE;
        const MAX_ROWS = CANVAS_SIZE / TILE_SIZE;
        const MAX_HIGH_SCORES = 5;
        
        // Speed Map
        const SPEED_MAP = {
            'Slow': 200, 'Medium': 150, 'Fast': 100, 'Expert': 50
        };
        const INITIAL_SPEED_KEY = 'Medium';
        
        // --- Game State ---
        let canvas, ctx;
        let snake;
        let food;
        let dx, dy;
        let score;
        let lastUpdateTime;
        let gameSpeed;
        let isPaused = true;
        let nextDx = 1;
        let nextDy = 0;
        let selectedSpeedKey = INITIAL_SPEED_KEY;

        // Tone.js Sound Objects
        let synth;
        let bassSynth;
        let audioContextStarted = false;

        // Touch State
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30;

        // Elements
        const scoreValueEl = document.getElementById('scoreValue');
        const speedValueEl = document.getElementById('speedValue');
        const modalEl = document.getElementById('gameModal');
        const modalTitleEl = document.getElementById('modalTitle');
        const modalTextEl = document.getElementById('modalText');
        const startButton = document.getElementById('startButton');
        const speedSelectorEl = document.getElementById('speedSelector');
        const highScoresDisplayEl = document.getElementById('highScoresDisplay');
        const newHighScoreFormEl = document.getElementById('newHighScoreForm');
        const playerNameInputEl = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const authStatusDisplayEl = document.getElementById('authStatusDisplay');
        const configWarningEl = document.getElementById('configWarning');
        const audioStartButton = document.getElementById('audio-start-btn');


        // --- Audio Functions ---

        /**
         * Initializes Tone.js synths with smoother settings.
         */
        function initAudio() {
            // Main Synth for pickup and start sounds (using sine for a clean, pleasing tone)
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" }, // Sine wave for non-sharp tone
                envelope: {
                    attack: 0.01, // Quick attack
                    decay: 0.1,
                    sustain: 0.0, // No sustain for a short pulse
                    release: 0.1,
                }
            }).toDestination();

            // Game Over Sound (Monophonic Synth with a low frequency - the sound you liked)
            bassSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.01,
                    decay: 0.8,
                    sustain: 0,
                    release: 0.5
                }
            }).toDestination();
            
            audioContextStarted = true;
        }

        /**
         * Plays the food pickup sound (single, clean, low-mid tone for a classic "coin" effect).
         */
        function playFoodSound() {
            if (!audioContextStarted) return;
            // Single, clean, mid-range sine note (C5) with a very short duration.
            synth.triggerAttackRelease("C5", "64n");
        }

        /**
         * Plays the game start sound (quick, descending ready tone).
         */
        function playStartSound() {
            if (!audioContextStarted) return;
            const now = Tone.now();
            // Distinct descending tone (C5 then G4)
            synth.triggerAttackRelease("C5", "16n", now);
            synth.triggerAttackRelease("G4", "16n", now + 0.08);
        }

        /**
         * Plays the game over sound. (The approved sound)
         */
        function playGameOverSound() {
            if (!audioContextStarted) return;
            bassSynth.triggerAttackRelease("C2", "1n");
        }
        
        /**
         * Handles the click to start the AudioContext on the user's first interaction.
         */
        function startAudioContext() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            initAudio();
            audioStartButton.style.display = 'none';
        }

        // --- Firebase & High Score Functions ---
        
        /**
         * Initializes Firebase and sets up anonymous authentication.
         */
        function setupFirebase() {
            try {
                // Initialize using the provided config
                const app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);
                
                authStatusDisplayEl.textContent = "Authenticating...";
                
                // Use onAuthStateChanged to ensure user is ready before using DB
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        isDbReady = true;
                        authStatusDisplayEl.textContent = "Online (Universal Leaderboard)";
                        configWarningEl.classList.remove('hidden'); // Show the instruction message
                        listenForHighScores(); 
                    } else {
                        // If no user, sign in anonymously
                        signInAnonymously(auth).catch(error => {
                            console.error("Firebase sign-in failed:", error);
                            isDbReady = false;
                            authStatusDisplayEl.textContent = "OFFLINE (Auth Error)";
                            highScoresDisplayEl.innerHTML = '<p class="text-red-400">Failed to connect to leaderboard. Check console/security rules.</p>';
                        });
                    }
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                isDbReady = false;
                authStatusDisplayEl.textContent = "OFFLINE (Config Error)";
                highScoresDisplayEl.innerHTML = '<p class="text-red-400">Failed to connect to leaderboard. Check console/security rules.</p>';
            }
        }

        /**
         * Listens to real-time updates for the top 5 scores from Firestore.
         */
        function listenForHighScores() {
            if (!db || !isDbReady) return;

            try {
                const scoresRef = collection(db, COLLECTION_NAME);
                
                // Query for the top 5 scores ordered by score descending
                // Sorting will be done in memory to avoid needing a Firestore index on 'score'.
                const q = query(scoresRef, limit(10)); // Fetch slightly more to ensure we have data, then sort in memory

                onSnapshot(q, (snapshot) => {
                    globalHighScores = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        globalHighScores.push({
                            id: doc.id,
                            name: data.name,
                            score: data.score,
                            speed: data.speed,
                            timestamp: data.timestamp ? data.timestamp.toDate() : new Date()
                        });
                    });
                    
                    // Sort the scores in memory since we avoided orderBy in the query
                    globalHighScores.sort((a, b) => b.score - a.score);
                    
                    // Truncate to the top 5
                    globalHighScores = globalHighScores.slice(0, MAX_HIGH_SCORES);

                    // Update the display whenever data changes or when the modal is first shown
                    if (modalEl.style.display !== 'none' || globalHighScores.length > 0) {
                        displayHighScores();
                    }
                }, (error) => {
                    console.error("Error listening to high scores:", error);
                    highScoresDisplayEl.innerHTML = '<p class="text-red-400">Failed to load scores. Check database path and rules.</p>';
                });
            } catch (e) {
                 console.error("Error setting up score listener:", e);
            }
        }
        
        /**
         * Renders the high scores table in the modal using globalHighScores array.
         */
        function displayHighScores() {
            const scores = globalHighScores;
            
            if (scores.length === 0) {
                highScoresDisplayEl.innerHTML = '<p class="text-gray-400">No universal high scores yet! Be the first.</p>';
                return;
            }

            let tableHTML = `
                <table class="high-scores-table">
                    <thead>
                        <tr>
                            <th class="score-rank">#</th>
                            <th>Player</th>
                            <th>Speed</th>
                            <th class="score-value">Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            scores.forEach((record, index) => {
                const name = (record.name || 'Anonymous').toUpperCase();
                const speed = record.speed || 'N/A';

                tableHTML += `
                    <tr>
                        <td class="score-rank">${index + 1}.</td>
                        <td>${name}</td>
                        <td>${speed}</td>
                        <td class="score-value">${record.score}</td>
                    </tr>
                `;
            });
            
            tableHTML += '</tbody></table>';
            highScoresDisplayEl.innerHTML = tableHTML;
        }

        /**
         * Checks if the current score qualifies for the top 5.
         */
        function isNewHighScore() {
            if (!isDbReady) return false; 
            
            // If the list is not full, any score is a high score
            if (globalHighScores.length < MAX_HIGH_SCORES) return true;
            
            // Check if the current score is higher than the lowest score on the list
            // Scores are sorted DESC, so the last element has the lowest score.
            return score > globalHighScores[globalHighScores.length - 1].score;
        }
        
        /**
         * Handles high score submission flow.
         */
        function checkAndHandleHighScore() {
            const qualified = isNewHighScore();

            if (qualified) {
                // Show form to save name
                newHighScoreFormEl.classList.remove('hidden');
                playerNameInputEl.value = '';
                playerNameInputEl.focus();

                // Set the click handler for the save button
                startButton.textContent = "Continue Without Saving";
                startButton.onclick = () => {
                    newHighScoreFormEl.classList.add('hidden');
                    modalTextEl.innerHTML = `Your Final Score: <strong style="color:var(--score-color);">${score}</strong>. Keep trying!`;
                    startButton.textContent = "Play Again";
                    startButton.onclick = startGame;
                }
                
            } else {
                // Not a high score
                newHighScoreFormEl.classList.add('hidden');
                modalTextEl.innerHTML = `Your Final Score: <strong style="color:var(--score-color);">${score}</strong>. Keep trying!`;
                startButton.textContent = "Play Again";
                startButton.onclick = startGame;
            }
            
            displayHighScores();
        }
        
        /**
         * Saves the player's name and score to the global high score collection.
         */
        async function submitHighScore() {
            if (!isDbReady) {
                console.error("Database not ready. Cannot save score.");
                return;
            }
            
            let name = playerNameInputEl.value.trim();
            if (name === '') {
                name = 'ANON';
            }
            
            // Prevent double submission by disabling the button temporarily
            saveScoreButton.disabled = true;
            saveScoreButton.textContent = 'Saving...';

            const newRecord = {
                name: name,
                score: score,
                speed: selectedSpeedKey,
                timestamp: serverTimestamp() // Use server timestamp for accurate ordering
            };
            
            try {
                const scoresRef = collection(db, COLLECTION_NAME);
                await addDoc(scoresRef, newRecord);
                
                // Success feedback and reset modal state
                newHighScoreFormEl.classList.add('hidden');
                modalTextEl.innerHTML = `Score saved globally! Your Final Score: <strong style="color:var(--score-color);">${score}</strong>.`;
                startButton.textContent = "Play Again";
                startButton.onclick = startGame;
            } catch (e) {
                console.error("Error saving high score:", e);
                modalTextEl.innerHTML = `Error saving score to database: ${e.message}. Please check your Firestore security rules.`;
                startButton.textContent = "Play Again";
                startButton.onclick = startGame;
            } finally {
                // Re-enable button
                saveScoreButton.disabled = false;
                saveScoreButton.textContent = 'Save Score';
            }
        }


        // --- UI and Game Logic ---

        function renderSpeedSelector() {
            speedSelectorEl.innerHTML = ''; 
            
            Object.keys(SPEED_MAP).forEach(key => {
                const isChecked = key === INITIAL_SPEED_KEY;
                
                const radioInput = document.createElement('input');
                radioInput.type = 'radio';
                radioInput.id = `speed-${key}`;
                radioInput.name = 'game-speed';
                radioInput.value = key;
                radioInput.checked = isChecked;
                radioInput.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedSpeedKey = key;
                    }
                });
                
                const label = document.createElement('label');
                label.htmlFor = `speed-${key}`;
                label.classList.add('speed-label');
                label.textContent = key;
                
                speedSelectorEl.appendChild(radioInput);
                speedSelectorEl.appendChild(label);
            });
            selectedSpeedKey = INITIAL_SPEED_KEY;
        }
        
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            
            setupFirebase(); // Initialize Firebase and Authentication
            
            // Check if audio context needs explicit start
            if (window.Tone && Tone.context.state !== 'running') {
                 audioStartButton.style.display = 'block';
                 audioStartButton.addEventListener('click', startAudioContext, { once: true });
            } else if (window.Tone) {
                 initAudio();
            }

            renderSpeedSelector();
            resetGame();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyPress);
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            startButton.addEventListener('click', startGame);
            saveScoreButton.addEventListener('click', submitHighScore);

            // Initial draw to show the board
            draw();
        }

        function resetGame() {
            snake = [
                { x: 6, y: 10 },
                { x: 5, y: 10 },
                { x: 4, y: 10 }
            ];

            dx = 1;
            dy = 0;
            nextDx = 1; // Initial direction is right
            nextDy = 0;
            score = 0;
            isPaused = true;

            scoreValueEl.textContent = score;
            speedValueEl.textContent = selectedSpeedKey;
            
            spawnFood();
        }

        function mainLoop(timestamp) {
            if (isPaused) return;

            // Set game speed based on selection
            gameSpeed = SPEED_MAP[selectedSpeedKey] || SPEED_MAP[INITIAL_SPEED_KEY];


            if (!lastUpdateTime) lastUpdateTime = timestamp;

            // Only update game state if enough time has passed based on gameSpeed
            if (timestamp - lastUpdateTime < gameSpeed) {
                requestAnimationFrame(mainLoop);
                return;
            }
            lastUpdateTime = timestamp;
            
            // Apply the next direction change
            dx = nextDx;
            dy = nextDy;

            update();
            draw();
            
            requestAnimationFrame(mainLoop);
        }
        
        function startGame() {
            // Re-evaluate game speed based on the currently selected radio button
            const selectedRadio = document.querySelector('input[name="game-speed"]:checked');
            if (selectedRadio) {
                selectedSpeedKey = selectedRadio.value;
            }
            
            gameSpeed = SPEED_MAP[selectedSpeedKey];
            speedValueEl.textContent = selectedSpeedKey;
            
            // Ensure audio is running when starting
            if (window.Tone && !audioContextStarted) {
                startAudioContext(); 
            }
            
            playStartSound(); // Play the start sound

            modalEl.style.display = 'none';
            resetGame(); 
            isPaused = false;
            lastUpdateTime = performance.now();
            requestAnimationFrame(mainLoop);
        }

        function gameOver() {
            isPaused = true;
            playGameOverSound(); // Play game over sound
            modalTitleEl.textContent = "Game Over!";
            
            checkAndHandleHighScore();
            
            modalEl.style.display = 'flex';
        }

        function spawnFood() {
            let newFood;
            let occupied;
            do {
                newFood = {
                    x: Math.floor(Math.random() * MAX_COLS),
                    y: Math.floor(Math.random() * MAX_ROWS)
                };

                // Check if the new food location overlaps with the snake
                occupied = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
                
            } while (occupied);

            food = newFood;
        }

        function update() {
            // Calculate the new head position
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Check for wall collision
            const wallCollision = head.x < 0 || head.x >= MAX_COLS || head.y < 0 || head.y >= MAX_ROWS;
            
            // Check for self collision (check new head against all existing segments)
            const selfCollision = snake.some((segment, index) => 
                // A collision occurs if the new head location matches any existing segment location
                segment.x === head.x && segment.y === head.y
            );

            if (wallCollision || selfCollision) {
                gameOver();
                return;
            }

            // Move the snake by adding the new head
            snake.unshift(head);

            // Check if food was eaten
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreValueEl.textContent = score;
                
                playFoodSound(); // Play food sound
                spawnFood();
            } else {
                // Remove the tail if no food was eaten
                snake.pop();
            }
        }

        function draw() {
            // Clear the canvas
            ctx.fillStyle = '#2c3648';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw the snake
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#059669' : 'var(--snake-color)'; // Darker head
                ctx.strokeStyle = '#2c3648';
                
                ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.strokeRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            // Draw the food (circle)
            ctx.fillStyle = 'var(--food-color)';
            ctx.beginPath();
            const foodCenterX = food.x * TILE_SIZE + TILE_SIZE / 2;
            const foodCenterY = food.y * TILE_SIZE + TILE_SIZE / 2;
            // Draw a smaller circle for a more retro look
            ctx.arc(foodCenterX, foodCenterY, TILE_SIZE / 2 * 0.7, 0, 2 * Math.PI); 
            ctx.fill();
        }

        function handleKeyPress(event) {
            // Handle modal actions on key press (Space/Enter)
            if (isPaused) {
                if (event.key === ' ' || event.key === 'Enter') {
                    if (newHighScoreFormEl.classList.contains('hidden')) {
                        // Start game if on the main start screen
                        startGame();
                    } else if (event.key === 'Enter' && newHighScoreFormEl.classList.contains('hidden') === false) {
                        // Save score if on the high score form and Enter is pressed
                        submitHighScore();
                    }
                }
                return;
            }

            // Handle game direction change
            const key = event.key.toLowerCase();
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;
            
            // Determine the next direction, preventing immediate reverse turns
            if ((key === 'arrowleft' || key === 'a') && !goingRight) {
                nextDx = -1; nextDy = 0;
            } else if ((key === 'arrowup' || key === 'w') && !goingDown) {
                nextDx = 0; nextDy = -1;
            } else if ((key === 'arrowright' || key === 'd') && !goingLeft) {
                nextDx = 1; nextDy = 0;
            } else if ((key === 'arrowdown' || key === 's') && !goingUp) {
                nextDx = 0; nextDy = 1;
            }
        }

        // --- Touch/Swipe Handlers ---

        function handleTouchStart(event) {
            if (isPaused) return;
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            // Prevent scrolling when touch starts on the canvas
            event.preventDefault();
        }

        function handleTouchMove(event) {
            if (isPaused || !touchStartX || !touchStartY) return;

            const touch = event.touches[0];
            const diffX = touch.clientX - touchStartX;
            const diffY = touch.clientY - touchStartY;

            // Only register swipe if distance exceeds threshold
            if (Math.abs(diffX) > SWIPE_THRESHOLD || Math.abs(diffY) > SWIPE_THRESHOLD) {
                
                const goingUp = dy === -1;
                const goingDown = dy === 1;
                const goingRight = dx === 1;
                const goingLeft = dx === -1;

                // Check for horizontal or vertical dominance
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Horizontal swipe
                    if (diffX > 0 && !goingLeft) { // Swiped Right
                        nextDx = 1; nextDy = 0;
                    } else if (diffX < 0 && !goingRight) { // Swiped Left
                        nextDx = -1; nextDy = 0;
                    }
                } else {
                    // Vertical swipe
                    if (diffY > 0 && !goingUp) { // Swiped Down
                        nextDx = 0; nextDy = 1;
                    } else if (diffY < 0 && !goingDown) { // Swiped Up
                        nextDx = 0; nextDy = -1;
                    }
                }
                
                // Reset touch start points to prevent rapid, unintended direction changes
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            }
            
            // Prevent default behavior (like scrolling) during touch move
            event.preventDefault();
        }
        
        function handleTouchEnd(event) {
            touchStartX = 0;
            touchStartY = 0;
        }
        
        // Start the game initialization when the window loads
        window.onload = init;
    </script>
    
    <!-- Service Worker Registration Script -->
    <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js");
    }
    </script>
</body>
</html>

