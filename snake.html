<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Swipe Snake Game (Speed Control)</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --game-bg: #1f2937; /* Dark blue-gray */
            --snake-color: #10b981; /* Emerald Green */
            --food-color: #f87171; /* Red */
            --score-color: #fcd34d; /* Amber */
            --active-speed: #34d399;
            --inactive-speed: #4b5563;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0f172a; /* Deeper background */
            font-family: 'VT323', monospace;
            color: #e5e7eb;
            user-select: none; /* Prevent selection on touchscreens */
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            border-radius: 16px;
            background-color: var(--game-bg);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            text-align: center;
            color: var(--score-color);
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            text-shadow: 0 0 5px rgba(252, 211, 77, 0.5);
        }

        #gameCanvas {
            border: 4px solid var(--snake-color);
            border-radius: 8px;
            background-color: #2c3648;
            touch-action: none; /* Critical for preventing browser swipe actions */
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            padding: 5px 0;
        }

        .score-box {
            color: var(--score-color);
        }

        .game-message, .controls-info {
            text-align: center;
            padding: 10px;
            font-size: 1.2rem;
            min-height: 30px;
        }

        .controls-info {
            font-size: 1rem;
            color: #9ca3af;
        }

        /* Modal styling for game over/start */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background: #374151;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 80%;
        }

        .modal-content h2 {
            color: var(--food-color);
            margin-top: 0;
        }
        .modal-content p {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .action-button {
            padding: 10px 20px;
            font-size: 1.5rem;
            font-family: 'VT323', monospace;
            color: var(--game-bg);
            background-color: var(--snake-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 0 #065f46; /* Darker green for depth */
            position: relative;
            top: 0;
            margin-top: 20px;
        }

        .action-button:active {
            box-shadow: 0 0 0 0 #065f46;
            top: 4px;
        }
        
        /* Speed Selection Styles */
        .speed-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .speed-label {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            background-color: var(--inactive-speed);
            color: #e5e7eb;
            font-size: 1rem;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Hide the actual radio input */
        .speed-selector input[type="radio"] {
            display: none;
        }
        
        /* Style the label when the corresponding radio is checked */
        .speed-selector input[type="radio"]:checked + .speed-label {
            background-color: var(--active-speed);
            color: var(--game-bg);
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>SNAKE SWIPE</h1>
        <div class="info-panel">
            <div class="score-box">Score: <span id="scoreValue">0</span></div>
            <div class="speed-box">Current Speed: <span id="speedValue">Medium</span></div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="controls-info">
            Use **WASD** or **Arrow Keys** on keyboard.
        </div>
        <div class="controls-info">
            **Swipe** on the canvas to control the snake on touch devices.
        </div>

        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">Welcome to Snake Swipe!</h2>
                
                <p>Select Speed:</p>
                <div class="speed-selector" id="speedSelector">
                    <!-- Speed radio buttons will be inserted here -->
                </div>
                
                <p id="modalText">Eat the red food to grow. Avoid the walls and your own tail!</p>
                <button id="startButton" class="action-button">Start Game</button>
            </div>
        </div>

    </div>

    <script type="module">
        // Game Constants
        const TILE_SIZE = 20;
        const CANVAS_SIZE = 400; // Must be divisible by TILE_SIZE
        const MAX_COLS = CANVAS_SIZE / TILE_SIZE;
        const MAX_ROWS = CANVAS_SIZE / TILE_SIZE;
        
        // Speed Map (ms delay between updates: lower is faster)
        const SPEED_MAP = {
            'Slow': 200, 
            'Medium': 150, 
            'Fast': 100, 
            'Expert': 50
        };
        const INITIAL_SPEED_KEY = 'Medium';
        
        // Game State
        let canvas, ctx;
        let snake;
        let food;
        let dx, dy; // Direction
        let score;
        let gameLoopId;
        let lastUpdateTime;
        let gameSpeed; // This will hold the ms value (e.g., 150)
        let isPaused = true;
        let nextDx = 1;
        let nextDy = 0;
        let selectedSpeedKey = INITIAL_SPEED_KEY; // Tracks the currently selected speed key

        // Touch State for Swiping
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30; // Minimum distance to register a swipe

        // Elements
        const scoreValueEl = document.getElementById('scoreValue');
        const speedValueEl = document.getElementById('speedValue');
        const modalEl = document.getElementById('gameModal');
        const modalTitleEl = document.getElementById('modalTitle');
        const modalTextEl = document.getElementById('modalText');
        const startButton = document.getElementById('startButton');
        const speedSelectorEl = document.getElementById('speedSelector');

        /**
         * Renders the speed selection radio buttons in the modal.
         */
        function renderSpeedSelector() {
            speedSelectorEl.innerHTML = ''; // Clear previous buttons
            
            Object.keys(SPEED_MAP).forEach(key => {
                const isChecked = key === INITIAL_SPEED_KEY;
                
                const radioInput = document.createElement('input');
                radioInput.type = 'radio';
                radioInput.id = `speed-${key}`;
                radioInput.name = 'game-speed';
                radioInput.value = key;
                radioInput.checked = isChecked;
                radioInput.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedSpeedKey = key;
                    }
                });
                
                const label = document.createElement('label');
                label.htmlFor = `speed-${key}`;
                label.classList.add('speed-label');
                label.textContent = key;
                
                speedSelectorEl.appendChild(radioInput);
                speedSelectorEl.appendChild(label);
            });
            // Ensure the initial state is set
            selectedSpeedKey = INITIAL_SPEED_KEY;
        }
        
        /**
         * Initializes the game state and event listeners.
         */
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;

            renderSpeedSelector();
            resetGame();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyPress);
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            startButton.addEventListener('click', startGame);

            // Initial Draw to show the board
            draw();
        }

        /**
         * Resets the snake, food, score, and direction.
         */
        function resetGame() {
            // Initial snake position (starts at 3 segments)
            snake = [
                { x: 6, y: 10 },
                { x: 5, y: 10 },
                { x: 4, y: 10 }
            ];

            // Initial direction (moving right)
            dx = 1;
            dy = 0;
            nextDx = 1;
            nextDy = 0;
            score = 0;
            // gameSpeed is set in startGame based on selection
            isPaused = true;

            scoreValueEl.textContent = score;
            speedValueEl.textContent = selectedSpeedKey;
            
            spawnFood();
            
            if (gameLoopId) {
                clearInterval(gameLoopId);
            }
        }

        /**
         * Main game loop that updates the game state.
         */
        function mainLoop(timestamp) {
            if (isPaused) return;

            // Throttle game updates based on gameSpeed
            if (timestamp - lastUpdateTime < gameSpeed) {
                requestAnimationFrame(mainLoop);
                return;
            }
            lastUpdateTime = timestamp;
            
            // Apply the intended direction after a delay to prevent immediate 180 turns
            dx = nextDx;
            dy = nextDy;

            update();
            draw();
            
            requestAnimationFrame(mainLoop);
        }
        
        /**
         * Starts the game loop.
         */
        function startGame() {
            // 1. Set the game speed based on the selection
            gameSpeed = SPEED_MAP[selectedSpeedKey] || SPEED_MAP[INITIAL_SPEED_KEY];
            speedValueEl.textContent = selectedSpeedKey;
            
            // 2. Hide modal and start game
            modalEl.style.display = 'none';
            resetGame(); // Ensure state is clean before starting
            isPaused = false;
            lastUpdateTime = performance.now();
            requestAnimationFrame(mainLoop);
        }

        /**
         * Displays the game over modal.
         */
        function gameOver() {
            isPaused = true;
            modalTitleEl.textContent = "Game Over!";
            modalTextEl.innerHTML = `Your Final Score: <strong style="color:var(--score-color);">${score}</strong>. The snake reached a length of ${snake.length}.`;
            startButton.textContent = "Play Again";
            modalEl.style.display = 'flex';
        }

        /**
         * Generates food coordinates randomly, ensuring it doesn't overlap with the snake.
         */
        function spawnFood() {
            let newFood;
            let occupied;
            do {
                // Generate random coordinates within the grid limits
                newFood = {
                    x: Math.floor(Math.random() * MAX_COLS),
                    y: Math.floor(Math.random() * MAX_ROWS)
                };

                // Check for overlap with snake
                occupied = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
                
            } while (occupied);

            food = newFood;
        }

        /**
         * Updates the position of the snake and checks for collisions (wall and self only).
         */
        function update() {
            // Create the new head
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // 1. Check for collisions (walls and self only)
            
            // Wall collision
            const wallCollision = head.x < 0 || head.x >= MAX_COLS || head.y < 0 || head.y >= MAX_ROWS;
            
            // Self collision (check if the new head position is the same as any body part)
            const selfCollision = snake.some((segment, index) => 
                index !== 0 && segment.x === head.x && segment.y === head.y
            );

            if (wallCollision || selfCollision) {
                gameOver();
                return;
            }

            // Add new head to the front
            snake.unshift(head);

            // 2. Check if food is eaten
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreValueEl.textContent = score;
                
                // Increase speed every 5 food items eaten (if the initial speed wasn't Expert)
                // This logic is simplified since the initial speed is now set by the user. 
                // We'll keep the dynamic speed increase based on points, but cap it.
                if (score % 50 === 0 && gameSpeed > SPEED_MAP['Expert']) {
                    gameSpeed -= 10; // Slightly slower acceleration step
                }

                spawnFood(); // Spawn new food
            } else {
                // Remove the tail if no food was eaten (moves the snake)
                snake.pop();
            }
        }

        /**
         * Draws the game elements on the canvas.
         */
        function draw() {
            // Clear the canvas
            ctx.fillStyle = '#2c3648'; // Canvas background
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw snake
            snake.forEach((segment, index) => {
                // Snake head is slightly different
                ctx.fillStyle = index === 0 ? '#059669' : 'var(--snake-color)'; 
                ctx.strokeStyle = '#2c3648';
                
                // Draw segment
                ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                // Optional: add a border for definition
                ctx.strokeRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            // Draw food
            ctx.fillStyle = 'var(--food-color)';
            ctx.beginPath();
            const foodCenterX = food.x * TILE_SIZE + TILE_SIZE / 2;
            const foodCenterY = food.y * TILE_SIZE + TILE_SIZE / 2;
            // Draw a circle for food for better contrast
            ctx.arc(foodCenterX, foodCenterY, TILE_SIZE / 2 * 0.7, 0, 2 * Math.PI);
            ctx.fill();
        }

        // --- Input Handling (Keyboard) ---

        /**
         * Handles keyboard input for direction change.
         */
        function handleKeyPress(event) {
            if (isPaused) {
                if (event.key === ' ' || event.key === 'Enter') {
                    startGame();
                }
                return;
            }

            const key = event.key;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            // Only allow change if it's not the opposite direction of current movement
            if ((key === 'ArrowLeft' || key === 'a') && !goingRight) {
                nextDx = -1; nextDy = 0;
            } else if ((key === 'ArrowUp' || key === 'w') && !goingDown) {
                nextDx = 0; nextDy = -1;
            } else if ((key === 'ArrowRight' || key === 'd') && !goingLeft) {
                nextDx = 1; nextDy = 0;
            } else if ((key === 'ArrowDown' || key === 's') && !goingUp) {
                nextDx = 0; nextDy = 1;
            }
        }


        // --- Input Handling (Touch/Swipe) ---

        /**
         * Records the start position of a touch gesture.
         */
        function handleTouchStart(event) {
            if (isPaused) return;
            // Record the initial touch position
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        /**
         * Calculates the swipe direction and updates the snake direction.
         * We use touchmove (or touchend) to determine the swipe direction.
         */
        function handleTouchMove(event) {
            if (isPaused || !touchStartX || !touchStartY) return;

            const touch = event.touches[0];
            const diffX = touch.clientX - touchStartX;
            const diffY = touch.clientY - touchStartY;

            // Determine if the movement is predominantly horizontal or vertical
            if (Math.abs(diffX) > SWIPE_THRESHOLD || Math.abs(diffY) > SWIPE_THRESHOLD) {
                const goingUp = dy === -1;
                const goingDown = dy === 1;
                const goingRight = dx === 1;
                const goingLeft = dx === -1;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Horizontal swipe
                    if (diffX > 0 && !goingLeft) {
                        nextDx = 1; nextDy = 0; // Right
                    } else if (diffX < 0 && !goingRight) {
                        nextDx = -1; nextDy = 0; // Left
                    }
                } else {
                    // Vertical swipe
                    if (diffY > 0 && !goingUp) {
                        nextDx = 0; nextDy = 1; // Down
                    } else if (diffY < 0 && !goingDown) {
                        nextDx = 0; nextDy = -1; // Up
                    }
                }
                
                // Reset start position immediately after a successful direction change
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            }
            
            // Prevent scrolling on the canvas
            event.preventDefault();
        }
        
        /**
         * Finalizes the touch gesture.
         */
        function handleTouchEnd(event) {
            // Reset touch state
            touchStartX = 0;
            touchStartY = 0;
        }


        // Start the application setup
        window.onload = init;
    </script>
</body>
</html>

